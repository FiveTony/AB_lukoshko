const link="wss://ab.wim.agency/api",appName="ab_game";class EventEmitter{constructor(){this.events=new Map}on(t,e){const s=this.events.get(t);s?s.add(e):this.events.set(t,new Set([e]))}emit(t,...e){const s=this.events.get(t);if(s)for(const t of s.values())t(...e)}remove(t,e){const s=this.events.get(t);s&&s.has(e)&&s.delete(e)}clear(t){t?this.events.delete(t):this.events.clear()}}const CALL_TIMEOUT=7e3,PING_INTERVAL=6e4,RECONNECT_TIMEOUT=2e3,connections=new Set;window.addEventListener("online",(()=>{for(const t of connections)t.connected||t.open()}));class MetacomError extends Error{constructor({message:t,code:e}){super(t),this.code=e}}class MetacomInterface{constructor(){this._events=new Map}on(t,e){const s=this._events.get(t);s?s.add(e):this._events.set(t,new Set([e]))}emit(t,...e){const s=this._events.get(t);if(s)for(const t of s.values())t(...e)}}class Metacom extends EventEmitter{constructor(t,e={}){super(),this.url=t,this.socket=null,this.api={},this.callId=0,this.calls=new Map,this.streams=new Map,this.active=!1,this.connected=!1,this.lastActivity=(new Date).getTime(),this.callTimeout=e.callTimeout||7e3,this.pingInterval=e.pingInterval||6e4,this.reconnectTimeout=e.reconnectTimeout||2e3,this.open()}static create(t,e){const{transport:s}=Metacom;return new(t.startsWith("ws")?s.ws:s.http)(t,e)}message(t){if("{}"===t)return;let e;this.lastActivity=(new Date).getTime();try{e=JSON.parse(t)}catch{return}const[s,n]=Object.keys(e),i=e[s],o=e[n];if(i&&o){if("callback"===s){const t=this.calls.get(i);if(!t)return;const[s,n]=t;return this.calls.delete(i),e.error?void n(new MetacomError(e.error)):void s(o)}if("event"===s){const[t,e]=n.split("/");this.api[t].emit(e,o)}if("stream"===s){const{name:t,size:s,status:n}=e;if(t){const e={name:t,size:s,chunks:[],received:0};return void this.streams.set(i,e)}const o=this.streams.get(i);if(n)return this.streams.delete(i),void new Blob(o.chunks).text().then((t=>{}))}}}async load(...t){const e=this.scaffold("system")("introspect"),s=await e(t),n=Object.keys(s);for(const e of t){if(!n.includes(e))continue;const t=new MetacomInterface,i=s[e],o=this.scaffold(e),a=Object.keys(i);for(const e of a)t[e]=o(e);this.api[e]=t}}scaffold(t,e){return s=>async(n={})=>{const i=++this.callId,o=(e?`${t}.${e}`:t)+"/"+s;return this.connected||await this.open(),new Promise(((t,e)=>{setTimeout((()=>{this.calls.has(i)&&(this.calls.delete(i),e(new Error("Request timeout")))}),this.callTimeout),this.calls.set(i,[t,e]);const s={call:i,[o]:n};this.send(JSON.stringify(s))}))}}}class WebsocketTransport extends Metacom{async open(){if(this.connected)return;const t=new WebSocket(this.url);return this.active=!0,this.socket=t,connections.add(this),t.addEventListener("message",(({data:t})=>{"string"!=typeof t||this.message(t)})),t.addEventListener("close",(()=>{this.connected=!1,setTimeout((()=>{this.active&&this.open()}),this.reconnectTimeout)})),t.addEventListener("error",(e=>{this.emit("error",e),t.close()})),setInterval((()=>{this.active&&(new Date).getTime()-this.lastActivity>this.pingInterval&&this.send("{}")}),this.pingInterval),new Promise((e=>{t.addEventListener("open",(async()=>{this.connected=!0,metacom.api.auth||await metacom.load("auth");const t=localStorage.getItem(appName);if(t){const e=await metacom.api.auth.restoreSession(t);"success"===e.status&&(metacom.isLogin=!0,localStorage.setItem(appName,e.token))}else{metacom.isLogin=!1;const t=await metacom.api.auth.register();"success"===t.status&&(metacom.isLogin=!0,localStorage.setItem(appName,t.token),this.login=!0)}let s=new Event("metaconnect",{bubbles:!0});document.dispatchEvent(s),e()}))}))}close(){this.active=!1,connections.delete(this),this.socket&&(this.socket.close(),this.socket=null)}send(t){this.connected&&(this.lastActivity=(new Date).getTime(),this.socket.send(t))}}class HttpTransport extends Metacom{async open(){this.active=!0,this.connected=!0}close(){this.active=!1,this.connected=!1}send(t){this.lastActivity=(new Date).getTime(),fetch(this.url,{method:"POST",headers:{"Content-Type":"application/json"},body:t}).then((t=>{const{status:e}=t;if(200===e)return t.text().then((t=>{if(t.error)throw new MetacomError(t.error);this.message(t)}));throw new Error(`Status Code: ${e}`)}))}}Metacom.transport={ws:WebsocketTransport,http:HttpTransport};const metacom=Metacom.create(link);window.metacom=metacom;class App{constructor(){this.waiting=[],metacom.emit()}acquire(){return new Promise(((t,e)=>{this.waiting.push({resolve:t,err:e})}))}take(){this.waiting.length>0&&this.waiting.shift().resolve()}async push(t,e,s={}){metacom.connected||await this.acquire(),this.take();try{return!(!t&&!e)&&(metacom.api[t]||await metacom.load(t),await metacom.api[t][e](s))}catch(t){return t}}}export default App;